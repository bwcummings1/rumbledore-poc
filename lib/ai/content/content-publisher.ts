// Content Publisher Service
// Sprint 10: Content Pipeline - Publishing and distribution

import { PrismaClient, ContentStatus } from '@prisma/client';
import { Server as SocketIOServer } from 'socket.io';
import { PublishingOptions, ContentNotification } from '@/types/content';

const prisma = new PrismaClient();

export class ContentPublisher {
  private io: SocketIOServer | null = null;

  constructor(io?: SocketIOServer) {
    if (io) {
      this.io = io;
    }
  }

  /**
   * Publish approved content
   */
  async publishContent(
    contentId: string, 
    options: PublishingOptions = {}
  ): Promise<string> {
    const content = await prisma.generatedContent.findUnique({
      where: { id: contentId },
      include: { league: true },
    });

    if (!content) {
      throw new Error(`Content ${contentId} not found`);
    }

    if (content.status !== ContentStatus.APPROVED) {
      throw new Error(`Content must be approved before publishing. Current status: ${content.status}`);
    }

    console.log(`[ContentPublisher] Publishing content: ${content.title}`);

    // Check if scheduled for future
    if (options.scheduledFor && new Date(options.scheduledFor) > new Date()) {
      // Schedule for future publishing
      await this.schedulePublishing(contentId, options.scheduledFor);
      return 'scheduled';
    }

    try {
      // Create blog post
      const blogPost = await prisma.blogPost.create({
        data: {
          leagueId: content.leagueId,
          leagueSandbox: content.leagueSandbox,
          title: content.title,
          slug: this.generateSlug(content.title, content.leagueId),
          content: this.processContentForPublishing(content.content),
          excerpt: options.excerpt || content.excerpt || this.generateExcerpt(content.content),
          authorType: 'AI',
          authorId: content.agentId,
          tags: options.tags || this.extractTags(content),
          featured: options.featured || false,
          publishedAt: new Date(),
        },
      });

      // Update generated content with published reference
      await prisma.generatedContent.update({
        where: { id: contentId },
        data: {
          status: ContentStatus.PUBLISHED,
          publishedAt: new Date(),
          publishedId: blogPost.id,
        },
      });

      // Send notifications
      if (options.notify !== false) {
        await this.notifySubscribers(blogPost, content.league);
      }

      // Emit real-time event
      if (this.io) {
        this.emitPublishEvent(blogPost, content.leagueSandbox);
      }

      console.log(`[ContentPublisher] Successfully published: ${blogPost.id}`);
      return blogPost.id;
    } catch (error) {
      console.error('[ContentPublisher] Publishing failed:', error);
      throw error;
    }
  }

  /**
   * Generate URL-safe slug
   */
  private generateSlug(title: string, leagueId: string): string {
    const baseSlug = title
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-+|-+$/g, '');

    // Add timestamp to ensure uniqueness
    const timestamp = Date.now().toString(36);
    return `${baseSlug}-${timestamp}`;
  }

  /**
   * Process content for publishing
   */
  private processContentForPublishing(content: string): string {
    // Add any final processing before publishing
    let processed = content;

    // Ensure proper line breaks for web display
    processed = processed.replace(/\n/g, '\n\n');

    // Add league watermark if needed
    if (!processed.includes('Generated by')) {
      processed += '\n\n---\n\n*Generated by Rumbledore AI*';
    }

    return processed;
  }

  /**
   * Generate excerpt from content
   */
  private generateExcerpt(content: string): string {
    // Remove markdown formatting
    const plain = content
      .replace(/^#+ /gm, '')
      .replace(/\*\*/g, '')
      .replace(/\*/g, '')
      .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1')
      .replace(/\n+/g, ' ')
      .trim();

    // Get first 200 characters
    if (plain.length <= 200) {
      return plain;
    }

    // Find sentence boundary
    const excerpt = plain.substring(0, 200);
    const lastPeriod = excerpt.lastIndexOf('.');
    if (lastPeriod > 100) {
      return excerpt.substring(0, lastPeriod + 1);
    }

    return excerpt + '...';
  }

  /**
   * Extract tags from content
   */
  private extractTags(content: any): string[] {
    const tags: Set<string> = new Set();

    // Add content type as tag
    if (content.type) {
      tags.add(content.type.toLowerCase().replace(/_/g, '-'));
    }

    // Add agent type as tag
    if (content.agentType) {
      tags.add(`by-${content.agentType.toLowerCase()}`);
    }

    // Extract keywords from title
    const titleWords = content.title
      .toLowerCase()
      .split(/\s+/)
      .filter((word: string) => word.length > 4);

    // Common fantasy football tags
    const commonTags = ['weekly', 'recap', 'power', 'rankings', 'matchup', 
                       'preview', 'trade', 'injury', 'playoff', 'championship'];
    
    for (const word of titleWords) {
      if (commonTags.includes(word)) {
        tags.add(word);
      }
    }

    // Extract week number if present
    const weekMatch = content.content.match(/week\s+(\d+)/i);
    if (weekMatch) {
      tags.add(`week-${weekMatch[1]}`);
    }

    return Array.from(tags).slice(0, 10); // Limit to 10 tags
  }

  /**
   * Schedule future publishing
   */
  private async schedulePublishing(contentId: string, scheduledFor: Date): Promise<void> {
    // This would integrate with the ContentScheduler service
    // For now, just update the metadata
    await prisma.generatedContent.update({
      where: { id: contentId },
      data: {
        metadata: {
          scheduledPublishing: scheduledFor.toISOString(),
        },
      },
    });
  }

  /**
   * Notify subscribers about new content
   */
  private async notifySubscribers(blogPost: any, league: any): Promise<void> {
    const notification: ContentNotification = {
      type: 'content_published',
      contentId: blogPost.id,
      leagueId: league.id,
      title: blogPost.title,
      message: `New content published: ${blogPost.title}`,
      timestamp: new Date(),
      metadata: {
        slug: blogPost.slug,
        authorType: blogPost.authorType,
        tags: blogPost.tags,
      },
    };

    // Get league members for notifications
    const members = await prisma.leagueMember.findMany({
      where: { leagueId: league.id },
      include: { user: true },
    });

    // Send notifications (would integrate with email/push service)
    for (const member of members) {
      console.log(`[ContentPublisher] Notifying ${member.user.email} about new content`);
      // Actual notification sending would go here
    }

    // Store notification in database
    await this.storeNotification(notification);
  }

  /**
   * Store notification for audit trail
   */
  private async storeNotification(notification: ContentNotification): Promise<void> {
    // This would store in a notifications table
    // For now, just log it
    console.log('[ContentPublisher] Notification stored:', notification);
  }

  /**
   * Emit real-time publish event
   */
  private emitPublishEvent(blogPost: any, leagueSandbox: string): void {
    if (!this.io) return;

    // Emit to league room
    this.io.to(`league:${leagueSandbox}`).emit('content:published', {
      id: blogPost.id,
      title: blogPost.title,
      slug: blogPost.slug,
      excerpt: blogPost.excerpt,
      tags: blogPost.tags,
      publishedAt: blogPost.publishedAt,
    });

    // Emit to global feed
    this.io.emit('content:new', {
      leagueId: blogPost.leagueId,
      title: blogPost.title,
      slug: blogPost.slug,
    });
  }

  /**
   * Unpublish content
   */
  async unpublishContent(blogPostId: string): Promise<void> {
    const blogPost = await prisma.blogPost.findUnique({
      where: { id: blogPostId },
    });

    if (!blogPost) {
      throw new Error(`Blog post ${blogPostId} not found`);
    }

    // Delete blog post
    await prisma.blogPost.delete({
      where: { id: blogPostId },
    });

    // Update generated content status
    await prisma.generatedContent.updateMany({
      where: { publishedId: blogPostId },
      data: {
        status: ContentStatus.ARCHIVED,
        publishedId: null,
        publishedAt: null,
      },
    });

    console.log(`[ContentPublisher] Unpublished content: ${blogPostId}`);
  }

  /**
   * Update published content
   */
  async updatePublishedContent(
    blogPostId: string, 
    updates: Partial<{
      title: string;
      content: string;
      excerpt: string;
      tags: string[];
      featured: boolean;
    }>
  ): Promise<void> {
    const blogPost = await prisma.blogPost.findUnique({
      where: { id: blogPostId },
    });

    if (!blogPost) {
      throw new Error(`Blog post ${blogPostId} not found`);
    }

    // Update blog post
    await prisma.blogPost.update({
      where: { id: blogPostId },
      data: {
        ...updates,
        updatedAt: new Date(),
      },
    });

    console.log(`[ContentPublisher] Updated published content: ${blogPostId}`);
  }

  /**
   * Get published content by slug
   */
  async getPublishedContent(slug: string, leagueId: string): Promise<any> {
    const blogPost = await prisma.blogPost.findFirst({
      where: {
        slug,
        leagueId,
      },
    });

    if (blogPost) {
      // Increment view count
      await prisma.blogPost.update({
        where: { id: blogPost.id },
        data: { viewCount: { increment: 1 } },
      });
    }

    return blogPost;
  }

  /**
   * Get recent published content
   */
  async getRecentContent(
    leagueId: string, 
    limit: number = 10,
    offset: number = 0
  ): Promise<any[]> {
    return await prisma.blogPost.findMany({
      where: { leagueId },
      orderBy: { publishedAt: 'desc' },
      take: limit,
      skip: offset,
    });
  }

  /**
   * Get featured content
   */
  async getFeaturedContent(leagueId: string): Promise<any[]> {
    return await prisma.blogPost.findMany({
      where: {
        leagueId,
        featured: true,
      },
      orderBy: { publishedAt: 'desc' },
      take: 5,
    });
  }

  /**
   * Get content by tags
   */
  async getContentByTags(leagueId: string, tags: string[]): Promise<any[]> {
    return await prisma.blogPost.findMany({
      where: {
        leagueId,
        tags: {
          hasSome: tags,
        },
      },
      orderBy: { publishedAt: 'desc' },
      take: 20,
    });
  }

  /**
   * Get publishing statistics
   */
  async getPublishingStats(leagueId: string): Promise<any> {
    const [total, published, views] = await Promise.all([
      prisma.generatedContent.count({
        where: { leagueId },
      }),
      prisma.blogPost.count({
        where: { leagueId },
      }),
      prisma.blogPost.aggregate({
        where: { leagueId },
        _sum: { viewCount: true },
      }),
    ]);

    // Get content by type
    const byType = await prisma.generatedContent.groupBy({
      by: ['type'],
      where: { 
        leagueId,
        status: ContentStatus.PUBLISHED,
      },
      _count: true,
    });

    // Get recent content
    const recent = await this.getRecentContent(leagueId, 5);

    return {
      totalGenerated: total,
      totalPublished: published,
      totalViews: views._sum.viewCount || 0,
      avgViewsPerPost: published > 0 ? (views._sum.viewCount || 0) / published : 0,
      byType: byType.reduce((acc, item) => {
        acc[item.type] = item._count;
        return acc;
      }, {} as Record<string, number>),
      recentContent: recent.map(post => ({
        id: post.id,
        title: post.title,
        slug: post.slug,
        publishedAt: post.publishedAt,
        viewCount: post.viewCount,
      })),
    };
  }
}